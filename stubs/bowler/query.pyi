from .helpers import (
    Once as Once,
    dotted_parts as dotted_parts,
    find_first as find_first,
    find_last as find_last,
    find_previous as find_previous,
    get_class as get_class,
    power_parts as power_parts,
    print_selector_pattern as print_selector_pattern,
    print_tree as print_tree,
    quoted_parts as quoted_parts,
)
from .imr import FunctionArgument as FunctionArgument, FunctionSpec as FunctionSpec
from .tool import BowlerTool as BowlerTool
from .types import (
    BowlerException as BowlerException,
    Callback as Callback,
    Capture as Capture,
    Filename as Filename,
    FilenameMatcher as FilenameMatcher,
    Filter as Filter,
    Hunk as Hunk,
    LN as LN,
    Processor as Processor,
    SENTINEL as SENTINEL,
    START as START,
    SYMBOL as SYMBOL,
    Stringish as Stringish,
    TOKEN as TOKEN,
    Transform as Transform,
)
from fissix.fixer_base import BaseFix  # type: ignore
from typing import Any, Callable, List, Optional, Type, TypeVar, Union

SELECTORS: Any
Q = TypeVar("Q", bound="Query")
QM = Callable[..., Q]
log: Any

def selector(pattern: str) -> Callable[[QM], QM]: ...

class Query:
    paths: Any = ...
    transforms: Any = ...
    processors: Any = ...
    retcode: Any = ...
    filename_matcher: Any = ...
    python_version: Any = ...
    exceptions: Any = ...
    def __init__(
        self,
        *paths: Union[str, List[str]],
        filename_matcher: Optional[FilenameMatcher] = ...,
        python_version: int = ...
    ) -> None: ...
    def select_root(self) -> Query: ...
    def select_module(self, name: str) -> Query: ...
    def select_class(self, name: str) -> Query: ...
    def select_subclass(self, name: str) -> Query: ...
    def select_attribute(self, name: str) -> Query: ...
    def select_method(self, name: str) -> Query: ...
    def select_function(self, name: str) -> Query: ...
    def select_var(self, name: str) -> Query: ...
    def select_pattern(self, pattern: str) -> Query: ...
    def select(self, pattern: str) -> Query: ...
    @property
    def current(self) -> Transform: ...
    def is_filename(self, include: str = ..., exclude: str = ...) -> Query: ...
    def is_call(self) -> Query: ...
    def is_def(self) -> Query: ...
    def in_class(self, class_name: str, include_subclasses: bool = ...) -> Query: ...
    def encapsulate(self, internal_name: str = ...) -> Query: ...
    def rename(self, new_name: str) -> Query: ...
    def add_argument(
        self,
        name: str,
        value: str,
        positional: bool = ...,
        after: Stringish = ...,
        type_annotation: Stringish = ...,
    ) -> Query: ...
    def modify_argument(
        self,
        name: str,
        new_name: Stringish = ...,
        type_annotation: Stringish = ...,
        default_value: Stringish = ...,
    ) -> Query: ...
    def remove_argument(self, name: str) -> Query: ...
    def fixer(self, fx: Type[BaseFix]) -> Query: ...
    def filter(self, callback: Union[str, Callback]) -> Query: ...
    def modify(self, callback: Union[str, Callback]) -> Query: ...
    def process(self, callback: Processor) -> Query: ...
    def create_fixer(self, transform: Any): ...
    def compile(self) -> List[Type[BaseFix]]: ...
    def execute(self, **kwargs: Any) -> Query: ...
    def dump(self, selector_pattern: Any = ...) -> Query: ...
    def diff(self, interactive: bool = ..., **kwargs: Any) -> Query: ...
    def idiff(self, **kwargs: Any) -> Query: ...
    def silent(self, **kwargs: Any) -> Query: ...
    def write(self, **kwargs: Any) -> Query: ...
