from .helpers import filename_endswith as filename_endswith
from .types import BadTransform as BadTransform, BowlerException as BowlerException, BowlerQuit as BowlerQuit, Filename as Filename, FilenameMatcher as FilenameMatcher, Fixers as Fixers, Hunk as Hunk, Processor as Processor, RetryFile as RetryFile
from fissix.refactor import RefactoringTool  # type: ignore
from typing import Any, Iterator, List, Optional, Sequence, Tuple

PROMPT_HELP: Any
log: Any

def diff_texts(a: str, b: str, filename: str) -> Iterator[str]: ...
def prompt_user(question: str, options: str, default: str=...) -> str: ...

class BowlerTool(RefactoringTool):
    NUM_PROCESSES: Any = ...
    IN_PROCESS: bool = ...
    queue_count: int = ...
    queue: Any = ...
    results: Any = ...
    semaphore: Any = ...
    interactive: Any = ...
    write: Any = ...
    silent: Any = ...
    in_process: Any = ...
    exceptions: Any = ...
    hunk_processor: Any = ...
    filename_matcher: Any = ...
    def __init__(self, fixers: Fixers, *args: Any, interactive: bool=..., write: bool=..., silent: bool=..., in_process: Optional[bool]=..., hunk_processor: Processor=..., filename_matcher: Optional[FilenameMatcher]=..., **kwargs: Any): ...
    def log_error(self, msg: str, *args: Any, **kwds: Any) -> None: ...
    def get_fixers(self) -> Tuple[Fixers, Fixers]: ...
    def processed_file(self, new_text: str, filename: str, old_text: str=..., *args: Any, **kwargs: Any) -> List[Hunk]: ...
    def refactor_file(self, filename: str, *a: Any, **k: Any) -> List[Hunk]: ...
    def refactor_dir(self, dir_name: str, *a: Any, **k: Any) -> None: ...
    def refactor_queue(self) -> None: ...
    def queue_work(self, filename: Filename) -> None: ...
    def refactor(self, items: Sequence[str], *a: Any, **k: Any) -> None: ...
    def process_hunks(self, filename: Filename, hunks: List[Hunk]) -> None: ...
    def apply_hunks(self, accepted_hunks: Any, filename: Any) -> None: ...
    def run(self, paths: Sequence[str]) -> int: ...
